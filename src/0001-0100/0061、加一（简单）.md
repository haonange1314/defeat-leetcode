## 题目描述

> 这是 LeetCode 上的 [66. 加一](https://leetcode-cn.com/problems/plus-one/)，难度为 **简单**。
>
> 关键字： `数组`、`临界值`

给定一个由 `整数` 组成的 `非空` 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 `0` 之外，这个整数不会以零开头。

**示例 1：**
```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**
```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**
```
输入：digits = [0]
输出：[1]
```

**提示：**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`

<hr>

## 解题思路
我们都知道，当一个数字加一之后，如果数字等于9的话，就会进位。所以针对使用数组存储的数组（高位在首位）。

可以分为三种情况：
1. 无进位：即最后一位是 `< 9` 的数字，此时只需要末位的数字 `+1` 就可以了。
2. 有进位但是首位没有进位：即除了数组的首位之外其他的位置都有可能进位，此时只需要当前位变为 `0`，前一位 `+1`就可以了。
3. 有进位且首位也进位：出现这种情况的只有一种可能，那就是数组的所有位置的数字都是 `9`，此时只需要开辟一个新数组，长度比之前大一位，首位设为 `1` 就行了，比如 `10`、`100`、`1000`、`10000`......
```java
class Solution {
    public int[] plusOne(int[] digits) {
        int len = digits.length;
        // 从后向前遍历数组
        for (int i = len - 1; i >= 0; i--) {
            int value = digits[i];
            if (value != 9) {
                // 不是9就加一直接返回
                digits[i] ++;
                return digits;
            } else {
                // 是9的话变为0继续遍历
                digits[i] = 0;
            }
        }
        // 到最后了还是没返回，说明上一位是9，所以将所有位变为0，首位是1
        digits = new int[len + 1];
        digits[0] = 1;
        return digits;
    }
}
```

<hr>

## 引用
我的 `github` 仓库已经同步建立，[点击访问](https://github.com/haonange1314/defeat-leetcode)
